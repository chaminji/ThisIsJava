# 07. 인터페이스
## 인터페이스의 역할

* 인터페이스는 객체의 사용 방법을 정의한 타입이다.

* 인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 중요한 역할을 한다.

* 인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다. 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출시킨다.

* 인터페이스를 사용하는 이유는 개발 코드를 수정하지 않고, 사용하는 객체를 변경할 수 있도록 하기 위해서이다.

## 인터페이스 선언

* 물리적 형태는 클래스와 동일하다.

### 인터페이스 선언

* 인터페이스 선언은 class 키워드 대신에 interface 키워드를 사용한다.

```java
[public] interface 인터페이스명 {...}
```

* 인터페이스 이름은 클래스 이름을 작성하는 방법과 동일하다.

* 인터페이스는 상수와 메소드만을 구성 멤버로 가진다.

* 객체로 생성할 수 없기 때문에 생성자 역시 가질 수 없다.

```java
interface 인터페이스명{
    //상수
    타입 상수명 = 값;
    //추상메소드
    타입 메소드명(매개변수, ...);
    //디폴트 메소드
    default 타입 메소드명(매개변수, ...);
    //정적 메소드
    static 타입 메소드명(매개변수) {...}
}
```

### 상수 필드 선언

* 상수는 인터페이스에 고정된 값으로 런타임 시에 데이터를 바꿀 수 없다. 상수를 선언할 때에는 반드시 초기값을 대입해야 한다.

* 인터페이스에서 선언된 필드는 모두 public static final의 특성을 갖기 때문에 생략하더라도 컴파일 과정에서 자동적으로 붙는다.

_[RemoteControl.java] 참고_

### 추상 메소드 선언

* 추상 메소드는 객체가 가지고 있는 메소드를 설명한 것으로 호출할 때, 어떤 매개값이 필요하고, 리턴 타입이 무언인지만 알려준다. 실행부는 객체가 가지고 있다.

* 인터페이스에서 선언된 추상 메소드는 모두 public abstract의 특성을 갖기 때문에 생략하더라도 컴파일 과정에서 자동적으로 붙는다.

_[RemoteControl.java] 참고_

### 디폴트 메소드 선언

* 디폴트 메소드는 인터페이스에 선언되지만 사실은 객체가 가지고 있는 인스턴스 메소드라고 생각해야 한다.

* 자바8에서 추가된 인터페이스의 새로운 멤버로, public 특성을 갖기 때문에 생략하더라도 컴파일 과정에서 자동적으로 붙는다.

_[RemoteControl.java] 참고_

### 정적 메소드 선언

* 객체가 없어도 인터페이스만으로 호출이 가능하다.

* 정적 메소드 또한 자바8에서 추가된 인터페이스의 새로운 멤버로, public 특성을 갖기 때문에 생략하더라도 컴파일 과정에서 자동적으로 붙는다.

_[RemoteControl.java] 참고_

## 인터페이스 구현

* 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출한다.

* 객체는 인터페이스에서 정의한 추상 메소드와 동일한 메소드 이름, 매개 타입, 리턴 타입을 가진 실체 메소드를 가지고 있어야 한다.

* 이러한 객체를 인터페이스의 구현(implement) 객체라고 하고, 구현 객체를 생성하는 클래스를 구현 클래스라고 한다.

### 구현 클래스

* 클래스 선언부에 implements 키워드를 추가하고 인터페이스명을 명시해야 한다.

_[Television.java] 참고_

_[Audio.java] 참고_

* 만약 인터페이스에 선언된 추상 메소드에 대응하는 실체 메소드를 구현 클래스가 작성하지 않으면 구현 클래스는 자동적으로 추상 클래스가 된다.

* 인터페이스로 구현 객체를 사용하려면 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다.

_[RemoteControllerExample.java] 참고_

### 익명 구현 객체

* 일회성의 구현 객체를 만들기 위해 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다.

* 그래서 소스 파일을 만들지 않고도 구현 객체를 만들 수 있는 방법을 제공하는데, 그것이 익명 구현 객체이다.

```java
//익명 구현 객체를 생성해서 인터페이스 변수에 대입하는 코드
인터페이스 변수 = new 인터페이스(){
    //인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}
```

_[RemoteControllerExample.java] 참고_

### 다중 인터페이스 구현 클래스

* 객체는 다수의 인터페이스 타입으로 사용할 수 있다.

* 예를 들어, 인터페이스 A와 인터페이스 B가 객체의 메소드를 호출할 수 있으려면 객체는 이 두 인터페이스를 모두 구현해야 한다.

```java
public class 구현클래스명 implements 인터페이스A, 인터페이스B{
    //인터페이스 A에 선언된 추상 메소드의 실체 메소드 선언
    //인터페이스 B에 선언된 추상 메소드의 실체 메소드 선언
}
```

_[Searchable.java] 참고_

_[SmartTelevision.java] 참고_

## 인터페이스 사용

* 인터페이스로 구현 객체를 사용하려면 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다.

```java
RemoteControl rc;
rc = new Television();
rc = new Audio();
```

### 추상 메소드 사용

* 구현 객체가 인터페이스 타입에 대입되면 인터페이스에 선언된 추상 메소드를 개발 코드에서 호출할 수 있게 된다.

```java
RemoteControl rc = new Television();
rc.turnOn();
rc.turnOff();
```

### 디폴트 메소드 사용

* 디폴트 메소드는 인터페이스에서 바로 사용할 수 없다.

* 디폴트 메소드는 추상 메소드가 아닌 인스턴스 메소드이므로 구현 객체가 있어야 사용할 수 있다.

_[Audio.java] 참고_

### 정적 메소드 사용

* 인터페이스의 정적 메소드는 인터페이스로 바로 호출이 가능하다.

## 타입 변환과 다형성

* 인터페이스도 다형성을 구현하는 기술이 사용된다.

* 인터페이스 타입에 어떤 구현 객체를 대입하느냐에 따라 실행 결과가 달라진다.

* 상속은 같은 종류의 하위 클래스를 만드는 기술이고, 인터페이스는 사용 방법이 동일한 클래스를 만드는 기술이라는 개념적 차이는 있지만 둘 다 다형성을 구현하는 기술이다.

### 자동 타입 변환(Promotion)

* 인터페이스 구현 클래스를 상속해서 자식 클래스를 만들었다면 자식 객체 역시 인터페이스 타입으로 자동 타입 변환시킬 수 있다.

### 필드의 다형성

* 상속에서는 타이어 클래스 타입에 한국 타이어와 금호 타이어라는 자식 객체를 대입해서 교체할 수 있었다.

* 인터페이스에서는 한국 타이어와 금호 타이어 모두 타이어 인터페이스에 있는 메소드를 가지고 있기 때문에 교체 가능한 객체에 해당한다.

```java
Car myCar = new Car();
myCar.frontLeftTire = new KumhoTire(); //객체 대신 다른 구현 객체
myCar.frontRightTire = new KumhoTire(); //대입 가능
```

### 인터페이스 배열로 구현 객체 관리

```java
//배열로 작성
Tire[] tires = {
    new HankookTire(),
    new HankookTire(),
    new HankookTire(),
    new HankookTire()
};

//타이어 교체 코드
tires[1] = new KumhoTire();

//run()메소드 작성
void run(){
    for(Tire tire : tires){
        tire.roll();
    }
}
```

### 매개 변수의 다형성

* 매개 변수의 타입이 인터페이스일 경우, 어떠한 구현 객체도 매개값으로 사용할 수 있고, 어떤 구현 객체가 제공되느냐에 따라 메소드의 실행 결과는 다양해질 수 있다.

### 강제 타입 변환(Casting)

* 구현 객체가 인터페이스 타입으로 자동 변환하면, 인터페이스에 선언된 메소드만 사용 가능하다.

* 하지만 구현클래스에 선언된 필드와 메소드를 사용해야 할 경우도 발생한다.

* 이때, 강제 타입 변환을 해서 다시 구현 클래스 타입으로 변환한 다음, 구현 클래스의 필드와 메소드를 사용할 수 있다.

### 객체 타입 확인(instanceof)

* 상속에서 객체 타입을 확인하기 위해서 instanceof를 사용한다.

* Vehicle 인터페이스 타입으로 변환된 객체가 Bus인지 확인하는 코드이다.

```ja;va
if(vehicle instanceof Bus){
    Bus bus = (Bus) vehicle
}
```

## 인터페이스 상속

* 인터페이스는 클래스와 달리 다중 상속을 허용한다.

* 하위 인터페이스를 구현하는 클래스는 하위 인터페이스의 메소드, 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 한다.

_[InterfaceA.java] 참고_

_[InterfaceB.java] 참고_

_[InterfaceC.java] 참고_

_[Implementation.java] 참고_

_[Example.java] 참고_

## 디폴트 메소드와 인터페이스 확장

* 디폴트 메소드는 인터페이스에 선언된 인스턴스 메소드이기 때문에 구현 객체가 있어야 사용할 수 있다.

### 디폴트 메소드의 필요성

* 인터페이스에서 디폴트 메소드를 허용한 이유는 기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서이다.

* 기존 인터페이스의 이름과 추상 메소드의 변경 없이 디폴트 메소드만 추가할 수 있기 때문에 구현 클래스를 그대로 사용하면서 새로 개발하는 클래스에 디폴트 메소드를 활용할 수 있다.

_[MyInterface.java] 참고_

_[MyClassA.java] 참고_

_[MyClassB.java] 참고_

_[DefaultMethodExample.java] 참고_

### 디폴트 메소드가 있는 인터페이스 상속

* 자식 인터페이스에서 디폴트 메소드를 활용하는 방법

    * 디폴트 메소드를 단순히 상속만 받는다.

    * 디폴트 메소드를 재정의해서 실행 내용을 변경한다.

    * 디폴트 메소드를 추상 메소드로 재선언한다.