# 02. 연산자
## 연산자와 연산식

* 프로그램에서 데이터를 처리하여 결과를 산출하는 것을 연산이라고 한다.

* 연산에 사용되는 표시나 기호를 연산자라고 하고, 연산되는 데이터는 피연산자라고 한다.

    * +, -, *, == 등은 연산자이고, x, y, z 변수는 피연산자이다.

* 연산자는 필요로 하는 피연산자의 수에 따라 단항, 이항, 삼항 연산자로 구분된다.

```java
++x; // 단항연산자
x + y; // 이항연산자
(sum>90) ? "A" : "B"; // 삼항 연산자
```

* 연산식은 반드시 하나의 값을 산출한다.

## 연산의 방향과 우선순위

* 프로그램에서는 연산자의 연산 방향과 연산자 간의 우선순위가 정해져 있다.

* 우선순위가 같은 경우에는 연산의 방향에 따라 달라지는데, 대부분의 연산자는 왼쪽에서부터 오른쪽으로 연산을 시작한다.

* 연산의 방향과 우선순위에 대해 정리한 것이다.

    1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다.

    2. 산술, 비교, 논리, 대입 연산자 순으로 우선순위를 가진다.

    3. 단항과 대입 연산자를 제외한 모든 연산의 방향은 왼쪽에서 오른쪽이다.

    4. 복잡한 연산식에는 괄호 ()를 사용해서 우선순위를 정해준다.

## 단항 연산자

* 단항 연산자는 피연산자가 단 하나뿐인 연산자를 말한다.

* 부호 연산자, 증감 연산자, 논리 부정 연산자, 비트 반전 연산자가 있다.

### 부호 연산자(+, -)

* 부호 연산자는 양수 및 음수를 표시하는 +, -를 말한다. boolean 타입과 char 타입을 제외한 나머지 기본 타입에 사용할 수 있다.

* 부호 연산자를 정수 및 실수 리터럴 앞에 붙여 양수 및 음수를 표현한다.

```java
int i1 = +100;
int i2 = -100;
double d1 = -3.14;
double d2 = -10.5;
```

* 변수 앞에 붙이는 경우, + 연산자는 부호를 유지하고 - 연산자는 부호를 반전시킨다.

* 부호 연산자를 사용할 때 주의할 점은 부호 연산자의 산출 타입은 int 타입이 된다는 것이다.

```java
short s = 100;
short result = -s; // 컴파일 에러 int 타입으로 선언해야 한다.
```

_[SingOperatorExample.java] 참고_

### 증감 연산자(++, --)

* 증감 연산자는 변수의 값을 1 증가(++) 시키거나 1 감소(--) 시키는 연산자를 말한다.

| 연산식      | 설명                                                 |
|------------|------------------------------------------------------|
| ++ 피연산자 | 다른 연산을 수행하기 전에 피연산자의 값을 1 증가시킴 |
| -- 피연산자 | 다른 연산을 수행하기 전에 피연산자의 값을 1 감소시킴 |
| 피연산자 ++ | 다른 연산을 수행한 후에 피연산자의 값을 1 증가시킴   |
| 피연산자 -- | 다른 연산을 수행한 후에 피연산자의 값을 1 감소시킴   |

* 연산식에서 증감 연산자만 있는 경우에는 증감 연산자가 변수 앞 또는 뒤 어디든 위치해도 상관없다.

* 하지만 다른 연산자와 함께 사용하는 연산식에서는 증감 연산자의 위치에 따라 연산식의 결과가 다르게 나오므로 주의해야 한다.

_[IncreaseDecreaseOperatorExample.java] 참고_

* 참고로 ++i 와 i=i+1 는 컴파일 하면 동일한 바이트 코드가 생성되어 연산 속도가 같다.

### 논리 부정 연산자(!)

* 논리 부정 연산자는 true를 false로, false를 true로 변경하기 때문에 boolean 타입에만 사용할 수 있다.

* 주로 조건문과 제어문에서 사용된다.

_[DenyLogicOperatorExample.java] 참고_

### 비트 반전 연산자(~)

* 비트 반전 연산자는 정수 타입의 피연산자에만 사용되며, 피연산자를 2진수로 표현했을 때 비트값인 0을 1로, 1은 0으로 반전한다.

* 비트 반전 연산자 산출 타입은 int 타입이 된다는 것을 주의해야 한다.

* 자바는 정수 값을 총 32비트의 이진 문자열로 리턴하는 Integer.toBinaryString() 메소드를 제공한다.

```java
String v1BinaryString = Integer.toBinaryString(10);
```

* Integer.toBinaryString() 메소드는 앞의 비트가 모두 0이면 0은 생략되고 나머지 문자열만 리턴한다.

_[BitReverseOperatorExample.java] 참고_

## 이항 연산자

* 이항 연산자는 피연산자가 두 개인 연산자를 말한다.

* 산술연산자, 문자열 연결 연산자, 대입 연산자, 비교 연산자, 논리 연산자, 비트 논리 연산자, 비트 이동 연산자 등이 있다.

### 산술 연산자(+, -, *, /, %)

* 산술 연산자는 일반적인 사칙연산 연산자와 나머지를 구하는 연산자까지 5개이다.

* 이미 알고 있는 연산과 비슷하며 주의할 점은 곱셈의 경우 *를, 나눗셈의 경의 /를 사용한다는 것이다.

* % 연산자는 나눗셈을 수행한 후, 몫이 아닌 나머지를 돌려주는 연산자이다.

* 피연산자들의 타입이 동일하지 않을 경우 사용되는 규칙이다.

    1. 피연산자들이 모두 정수 타입이고 int 타입보다 작은 경우 모두 int 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 산출 타입은 int이다.

    2. 피연산자들이 모두 정수 타입이고, long 타입이 있을 경우 모두 long 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 산출 타입은 long이다.

    3. 피연산자 중 실수 타입이 있을 경우, 크기가 큰 실수 타입으로 변환 후, 연산을 수행한다. 따라서 연산의 산출 타입은 실수 타입이다.

_[ArithmeticOperatorExample.java] 참고_

* char 타입도 산술 연산이 가능하지만, 산출 타입은 int이다.

_[CharOperationExample.java] 참고_

#### 오버플로우 탐지

* 산술 연산에서 주의할 점은 연산 후의 산출값이 산출 타입으로 충분히 표현 가능한지 살펴봐야 한다.

_[OveflowExample.java] 참고_

_[CheckOverflowExample.java] 참고_

#### 정확한 계산은 정수 사용

* 정확하게 계산해야 할 때는 부동소수점(실수) 타입을 사용하지 않는 것이 좋다.

_[AccuracyExample.java] 참고_

#### NaN과 Infinity 연산

* 좌측 피연산자가 정수 타입인 경우 나누는 수인 우측 피연산자는 0을 사용할 수 없다. 실행 시 예외가 발생한다.

```java
5 / 0 // ArithmeticException 예외 발생
5 % 0 // ArithmeticException 예외 발생
```

* 실수 타입인 0.0 또는 0.0f로 나누면 예외가 발생하지 않고, / 연산의 결과는 Infinity 값을 가지며, % 연산의 결과는 NaN(Not a Number)을 가진다.

* 위의 경우 그 다음 연산을 실행해서는 안된다.

### 문자열 연결 연산자(+)

* 문자열 연결 연산자인 +는 문자열을 서로 결합하는 연산자이다. 

* 피연산자 중 한쪽이 문자열이면 + 연산자는 문자열 연결 연산자로 사용되어 다른 피연산자를 문자열로 변환하고 서로 결합한다. 

_[StringConcatExample.java] 참고_

### 비교 연산자(<, <=, >, >=, ==, !=)

* 비교는 대소 또는 동등을 비교해서 boolean 타입인 true/false를 산출한다.

* 비교 연산자는 흐름 제어문인 조건문, 반복문 에서 주로 사용되어 흐름을 제어할 때 사용한다.

* 피연산자가 char 타입이면 유니코드 값으로 비교 연산을 수행한다.

_[CompareOperatorExample.java] 참고_

* String 타입의 경우 비교 연산자를 사용하면 String 객체의 번지값을 비교하므로 문자열만을 비교하고 싶을 경우 equals() 메소드를 사용해야 한다.

_[StringEqualsExample.java] 참고_

### 논리 연산자(&&, ||, &, |, ^, !)

* 논리 연산자는 논리곱(&&), 논리합(||), 배타적 논리합(^), 논리 부정(!) 연산을 수행한다.

* &&와 &는 산출 결과는 같지만 연산 과정에 조금 차이가 있다.

    * &&는 앞의 피연산자가 false라면 뒤의 피연산자를 평가하지 않고 바로 false라는 결과를 낸다.

    * &는 두 피연산자 모두를 평가해서 산출 결과를 낸다.

    * 따라서 &보다 &&가 더 효율적이다.

    * ||와 |도 마찬가지이다.

_[LogicalOperatorExample.java] 참고_

### 비트 연산자(&, |, ^, ~, <<, >>, >>>)

* 비트 연산자는 데이터를 비트 단위로 연산한다.

* 0과 1이 피연산자가 되고, 0과 1로 표현이 가능한 정수 타입만 비트 연산을 할 수 있다.

* 비트 연산자는 기능에 따라 비트 논리 연산자와 비트 이동 연산자로 구분한다. 

#### 비트 논리 연산자(&, |, ^, ~)

* 비트 연산자는 피연산자를 int 타입으로 자동 타입 변환한 후 연산을  수행한다. 

| 구분       | 설명     |
|--------------------|------------------------------------------------------------|
| AND(논리곱)        | 두 비트 모두 1일 경우에만 연산 결과가 1                    |
| OR(논리합)         | 두 비트 중 하나만 1이면 연산 결과는 1                      |
| XOR(배타적 논리합) | 두 비트 중 하나는 1이고 다른 하나가 0일 경우 연산 결과는 1 |
| NOT(논리부정)      | 보수                                       |

_[BitLogicExample.java] 참고_

#### 비트 이동 연산자(<<, >>, >>>)

* 비트 이동 연산자는 정수 데이터의 비트를 좌측 또는 우측으로 밀어서 이동시키는 연산을 수행한다.

    * a << b : 정수 a의 각 비트를 b만큼 왼쪽으로 이동(빈자리는 0)              

    * a >> b : 정수 a의 각 비트를 b만큼 오른족으로 이동(빈자리는 정수 a의 최상위 부호 비트와 같은 값)

    * a >>> b : 정수 a의 각 비트를 b만큼 오른쪽으로 이동(빈자리는 0)

### 대입 연산자(=, +=, -=, *=, /=, %=, ^=, !=, <<=, >>=, >>>=)

* 대입 연산자는 오른쪽 피연산자의 값을 좌측 피연산자인 변수에 저장한다.

* 대입 연산자는 모든 연산자들 중에서 가장 낮은 연산 순위를 가지고 있기 떄문에 가장 마지막에 수행된다.

* 연산의 진행 방향이 오른쪽에서 왼쪽이다.

_[AssignmentOperatorExample.java] 참고_

## 삼항 연산자

* 삼항 연산자는 세 개의 연산자를 필요로 하는 연산자를 말한다.

```java
조건식(피연산자1) ? 값 또는 연산식(피연산자2) : 값 또는 연산식(피연산자3)
```

* 조건식이 true 일 경우 결과는 피연산자2이고, false 일 경우 결과는 피연산자3이 된다.

* 삼항 연산자는 if문으로 변경해서 작성할 수도 있지만, 간단하게 사용할 경우에는 삼항 연산자를 사용하는 것이 더 효율적이다.

_[ConditionalOperationExample.java] 참고_
