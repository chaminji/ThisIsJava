# 05. 클래스
## 인스턴스 멤버와 this

* 인스턴스 멤버란 객체를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다.

* 지금까지 작성한 모든 필드와 메소드는 인스턴스 멤버들이었다.

* 객체 내부에서 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다.

* 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우 this를 사용한다.

```java
Car(String model){
    this.model = model;
}
void setModel(String model){
    this.model = model;
}
```

_[Car4.java] 참고_
_[Car4Example.java] 참고_

## 정적 멤버와 static

* 정적(static)은 '고정된'이란 의미를 가지고 있다.

* 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.

### 정적 멤버 선언

* 필드와 메소드 선언시 static 키워드를 추가적으로 붙이면 된다.

```java
public class 클래스{
    //정적 필드
    static 타입 필드 [ = 초기값];

    //정적 메소드
    static 리턴 타입 메소드(매개변수 선언, ... ) { ... }
}
```

* 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언하고, 공용적인 데이터는 정적 필드로 선언하면 좋다.

```java
public class Calculator{
    String color; //계산기별로 색이 다를 수 있다.
    static double pi = 3.14159; //계산기에서 사용하는 파이 값은 동일
    static plus(int x, int y){ ... }
}
```

### 정적 멤버 사용

* 클래스가 메모리로 로딩되면 사용할 수 있는데, 클래스 이름과 도트 연산자로 접근한다.

```java
int result = Calculator.plus(10,5);
```

* 원칙적으로는 클래스 이름으로 접근해야 하지만 객체 참조 변수로도 접근 가능하다.

* 하지만 클래스 이름으로 접근하는 것이 좋다.

```java
Calculator myCalc = new Calculator();
int result2 = myCalc.plus(10,5);
```

### 정적 초기화 블록

* 자바는 정적 필드의 복잡한 초기화 작업을 위해 정적 블록을 제공한다.

```java
static{
    ...
}
```

_[Television.java] 참고_

_[TelevisionExample.java] 참고_

#### 정적 메소드와 블록 선언 시 주의할 점

* 인스턴스 필드나 인스턴스 메소드, this 키워드 사용이 불가능하다.

* 인스턴스 멤버를 사용하고 싶다면 객체를 생성한 후, 참조 변수로 접근해야 한다.

### 싱글톤

* 싱글톤은 단 하나만 생성되는 객체이다.

* 생성자를 외부에서 호출할 수 없도록 생성자 앞에 private 접근 제한자를 붙여주면 된다.

* 대신 외부에서 호출할 수 있는 정적 메소드 getInstance()를 선언해준다.

```java
//싱글톤을 만드는 코드
public class 클래스{
    //정적 필드
    private static 클래스 singleton = new 클래스();

    //생성자
    private 클래스(){}

    //정적 메소드
    static 클래스 getInstance(){
        return singleton;
    }
}
```

* getInstance() 메소드는 단 하나의 객체만 리턴하기 때문에 아래 코드의 변수1과 변수2는 동일한 객체를 참조한다.

```java
클래스 변수1 = 클래스.getInstance();
클래스 변수2 = 클래스.getInstance();
```

_[Singleton.java] 참고_

_[SingletonExample.java] 참고_

## final 필드와 상수

### final 필드

* final 필드는 초기값이 저장되면 이것이 최종적인 값이 되어 프로그램 실행 도중에 수정할 수 없는 것이다.

```java
final 타입 필드 [= 초기값];
```

* final 필드에 초기값을 주는 방법은 필드 선언시 주는 방법과 생성자에서 주는 방법, 두 가지 밖에 없다.

_[Person.java] 참고_

_[PersonExample.java] 참고_

### 상수(static final)

* 상수는 객체마다 저장되지 않고, 클래스에만 포함되며 한 번 초기값이 저장되면 변경할 수 없다.

_[Earth.java] 참고_

_[EarthExample.java] 참고_

## 접근 제한자

* 생성자를 호출하지 못하게 하거나 객체의 특정 데이터를 보호하기 위해서 접근 제한자를 사용한다.

| 접근 제한 | 적용 대상                 | 접근할 수 없는 클래스                          |
|---------|---------------------------|------------------------------------------------|
| public    | 클래스,필드,생성자,메소드 | 없음                                           |
| protected | 필드,생성자,메소드        | 자식 클래스가 아닌 다른 패키지에 소속된 클래스 |
| default   | 클래스,필드,생성자,메소드 | 다른 패키지에 소속된 클래스                    |
| private   | 필드,생성자,메소드        | 모든 외부 클래스                               |

### 클래스의 접근 제한

* 클래스를 선언할 때 같은 패키지 내에서만 사용할 것인지 다른 패키지에서도 사용할 것인지를 결정해야 한다.

#### default 접근 제한

* 클래스가 default 접근 제한을 가지게 되면 같은 패키지에서는 제한 없이 사용할 수 있지만 다른 패키지에서는 사용할 수 없도록 제한된다.

#### public 접근 제한

* 클래스가 public 접근 제한을 가지게 되면 다른 패키지에서도 아무런 제한 없이 사용할 수 있다.

### 생성자의 접근 제한

* 생성자는 public, protected, default, private 접근 제한을 가질 수 있다.

* 생성자를 선언하지 않으면 자동적으로 기본 생성자가 추가되는데, 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일하다.

### 필드와 메소드의 접근 제한

* 필드는 public, protected, default, private 접근 제한을 가질 수 있다.

## Getter와 Setter 메소드

* 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접 접근하는 것을 막는다.

* 객체의 데이터를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨질 수 있기 때문이다.

* 이 때문에 객체 지향 프로그래밍은 메소드를 통해서 데이터를 변경하는 방법을 선호한다.

* 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서 메소드를 통해 접근하도록 유도한다. 이 때, Setter 메소드를 이용한다.

* 외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는데, 메소드로 필드값을 가공한 후 외부로 전달한다. 이 때, Getter 메소드를 이용한다.

```java
private 타입 fieldName;

//Getter
public 리턴 타입 getFieldName(){
    return fieldName;
}

//Setter
public void setFieldName(타입 fieldName){
    this.fieldName = fieldName;
}
```

## 어노테이션

* 어노테이션은 메타데이터라고 볼 수 있다.

* 컴파일과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다.

* 어노테이션은 다음 세 가지 용도로 사용된다.

    * 컴파일러에게 코드 문법 에러롤 체크하도록 정보를 제공

    * 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공

    * 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공

### 어노테이션 타입 정의와 적용

* @interface를 사용해서 어노테이션을 정의하며, 그 뒤에 어노테이션 이름이 온다.

```java
public @interface AnnotationName{

}
//사용
@AnnotationName
```

* 어노테이션은 엘리먼트를 멤버로 가질 수 있다.

* 각 엘리먼트는 타입과 이름으로 구성되며, 디폴트 값을 가질 수 있다.

* 엘리먼트는 기본 데이터 타입과 이들의 배열 타입을 사용할 수 있다.

* Value 엘리먼트를 가진 어노테이션을 코드에서 적용할 때는 값만 기술할 수 있다. 이 값은 기본 엘리먼트인 value 값으로 자동 설정된다.

```java
@AnnotationName("값");
```

### 어노테이션 적용 대상

* 어노테이션을 적용할 수 있는 대상은 java.lang.annotation.ElementType 열거 상수이다.

* 어노테이션이 적용될 대상을 지정할 때에는 @Target 어노테이션을 사용한다.

### 어노테이션 유지 정책

* 어노테이션 정의 시 사용 용도에 따라 @AnnotationName을 어느 범위까지 유지할 것인지 지정해야 한다.

* 어노테이션 유지 정책은 java.lang.annotation.RetentionPolicy 열거 상수로 다음과 같이 정의 되어 있다.

|열거 상수 | 설명                                                                                                              |
|---------------------------|-------------------------------------------------------------------------------------------------------------------|
| SOURCE                    | 소스상에서만 어노테이션 정보를 유지한다. 소스 코드를 분석할 때만 의미가 있다.                                     |
| CLASS                     | 바이트 코드 파일까지 어노테이션 정보를 유지한다. 리플렉션을 이용해서 어노테이션 정보를 얻을 수는 없다.            |
| RUNTIME                   | 바이트 코드 파일까지 어노테이션 정보를 유지하면서 리플렉션을 이용해서 런타임 시에 어노테이션 정보를 얻을 수 있다. |

### 런타임 시 어노테이션 정보 사용하기

* 리플렉션을 이용해서 어노테이션의 적용 여부와 엘리먼트 값을 읽고 적절히 처리할 수 있다.

* 클래스에 적용된 어노텡이션 정보는 java.lang.Class를 이용하면 된다.

* 필드, 생성자, 메소드에 적용된 어노테이션 정보는 java.lang.reflect 패키지의 Field, Constructor, Method 타입의 배열을 얻어야 한다.

_[PrintAnnotation.java] 참고_

_[Service.java] 참고_

_[PrintAnnotationExample.java] 참고_