# 05. 클래스
## 객체 지향 프로그래밍

* 부품에 해당하는 객체를 먼저 만들고, 이를 하나씩 조립해서 완성된 프로그램을 만드는 기법이 객체 지향 프로그래밍(OOP : Object Oriented Programming)이다.

### 객체란?

* 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다.

    * 예를 들어 물리적으로 존재하는 자동차, 사람, 책과 추상적인 학과, 강의 등이 있다.

    * 사람은 이름, 나이 등의 속성과 웃다, 걷다 등의 동작이 있다.

* 이 속성과 동작들을 각각 필드와 메소드라고 부른다.

* 현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 객체 모델링이라고 한다.

### 객체의 상호작용

* 현실 세계에서 일어나는 모든 현상은 객체와 객체 간의 상호작용으로 이루어져 있다.

* 객체 사이의 상호작용 수단은 메소드이고, 객체가 다른 개체의 기능을 이용하는 것이 메소드 호출이다.

### 객체 간의 관계

* 객체는 대부분 다른 객체와 관계를 맺고 있다.

*  관계의 종류에는 집합 관계, 사용 관계, 상속 관계가 있다.

    * 집합 관계는 부품인 객체와 완성품인 객체의 관계이다.

    * 사용 관계는 객체 간의 상호작용을 말한다.

    * 상속 관계는 상위 객체를 기반으로 하위 객체를 생성하는 관계이다.

### 객체 지향 프로그래밍의 특징

#### 캡슐화

* 캡슐화란 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다.

* 외부의 잘못된 사용으로 객체가 손상되는 것을 막는다.

* 캡슐화된 멤버를 노출시킬지 숨길지를 결정하기 위해 접근 제한자를 사용한다.

#### 상속

* 상위 객체가 자신의 필드와 메소드를 하위 객체에게 물려주는 것을 의미한다.

* 하위 객체를 쉽고 빨리 설계할 수 있도록 도와준다.

* 효율적으로 개발할 수 있으며 개발 시간도 줄여준다.

#### 다형성

* 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다.

* 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다.

* 다형성의 효과로 객체는 부품화가 가능하다.

## 객체와 클래스

* 객체를 생성하기 위한 설계도가 클래스이다.

* 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스라고 한다.

## 클래스 선언

* 클래스 이름을 정하고 "클래스이름.java"로 소스 파일을 생성해야 한다.

```java
public class 클래스이름{

}
```

* 일반적으로 소스 파일당 하나의 클래스를 선언한다.

* 두 개 이상의 클래스 선언도 가능하지만, 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다.

## 객체 생성과 클래스 변수

* 클래스 선언 후, 컴파일을 했다면 객체를 생성할 설계도가 만들어진 셈이다.

* 클래스로부터 객체를 생성하려면 new 연산자를 사용하면 된다.

* new 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다.

```java
new 클래스();
```

* 클래스는 두 가지 용도가 있다.

* 하나는 라이브러리용이고 다른 하나는 실행용이다.

    * 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다.

    * 실행 클래스는 프로그램의 실행 진입점인 main() 메소드를 제공한다.

_[Student.class] 참고_
_[StudentExample.class] 참고_

## 클래스의 구성 멤버

* 클래스의 구성 멤버에는 필드(Field), 생성자(Constructor), 메소드(Method)가 있다.

```java
public class ClassName{
    //필드
    int fieldName;

    //생성자
    ClassName() { ... }

    //메소드
    void methodName() { ... }
}
```

### 필드

* 필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다.

* 생성자와 메소드 전체에서 사용되며 객체와 함께 존재한다.

### 생성자

* 생성자는 new 연산자로 호출되는 특별한 중괄호 {} 블록이다.

* 객체 생성시 초기화를 담당하며, 필드 초기화, 메소드 호출 후 객체 사용 준비를 한다.

* 리턴 타입이 없다.

### 메소드

* 메소드는 객체의 동작에 해당하는 중괄호 {} 블록이다.

* 메소드를 호출하면 중괄호 블록 내의 모든 코드가 실행된다.

* 메소드는 객체 간의 데이터 전달의 수단으로 사용되며, 매개값을 받을 수도, 실행 후 값을 리턴할 수도 있다.

## 필드

* 필드는 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳이다.

    * 자동차를 예로 들어보면 제작회사, 모델, 색깔은 고유 데이터이다.

    * 현재 속도, 엔진 회전 수는 상태 데이터에 해당한다.

    * 차체, 엔진, 타이어는 부품에 해당한다.

### 필드 선언

* 필드 선언은 클래스 중괄호 {} 블록 어디서든 존재할 수 있다.

* 생성자 선언과 메소드 선언의 앞과 뒤에서 선언이 가능하다.

* 필드의 초기값은 필드 선언 시 주어질 수도, 생략될 수도 있다.

```java
String company = "현대자동차";
String model = "그랜저";
int maxSpeed = 300;
int productionYear;
boolean engineStart;
```

### 필드 사용

* 필드를 사용한다는 것은 필드값을 읽고, 변경하는 작업을 말한다.

* 클래스 내부의 생성자나 메소드에서 사용할 경우 필드 이름으로 읽고 변경하면 된다.

* 클래스 외부에서 사용할 경우 먼저 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다.

* 필드는 객체에 소속되어서 객체가 존재하지 않으면 필드도 존재하지 않기 때문이다.

## 생성자

* new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.

### 기본 생성자

* 클래스 내부에 생성자 선언을 생략한다면 컴파일러는 기본 생성자를 바이트 코드에 자동 추가시킨다.

```java
//소스파일(Car.java)
public class Car{

}
//파이트코드파일(Car.class)
public class Car{
    public Car(){ } //자동 추가
}
```

### 생성자 선언

* 생성자를 명시적으로 선언하려면 다음과 같은 형태로 작성하면 된다.

```java
클래스 ( 매개변수 선언, ... ) {
    //객체의 초기화 코드ㅡ
}
```

* 앞에서 다룬 Car크래스에서 생성자를 선언해보면 다음과 같다.

```java
public class Car{
    Car(String model, String color, int maxSpeed) { ... }
}
```

### 필드 초기화

* 객체가 생성될 때 필드는 기본 초기값으로 자동 설정된다.

* 다른 값을 주고 싶다면 필드를 선언할 때 초기값을 주거나 생성자에서 초기값을 주는 방법이 있다.

* 필드를 선언할 때 초기값을 주게 되면 동일한 클래스로부터 생성되는 객체들은 모두 같은 데이터를 갖게 된다.

_[Korean.java] 참고_

_[KoreanExample.java] 참고_

* 필드와 매개변수 이름이 동일한 경우, 필드 앞에 "this."를 붙인다.

### 생성자 오버로딩

* 외부의 다양한 데이터를 이용해서 객체를 초기화하려면 생성자도 다양화될 필요가 있다.

* 생성자 오버로딩이란 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다.

```java
public class Car {
    Car() { ... }
    Car(String model) { ... }
    Car(String model, String color) { ... }
}
```

* 주의할 점은 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우에는 해당하지 않는다.

_[Car.java] 참고_

_[CarExample.java] 참고_

### 다른 생성자 호출(this())

* 생성자에서 다른 생성자를 호출할 때에는 this() 코드를 사용한다.

```java
Car(String model){
    this.model = model;
    this.color = "은색";
    this.maxSpeed = 250;
}

Car(String model, String color){
    this.model = model;
    this.color = color;
    this.maxSpeed = 250;
}

Car(String model, String color, int maxSpeed){
    this.model = model;
    this.color = color;
    this.maxSpeed = maxSpeed;
}

//중복 코드를 줄이기
//생성자
Car(){
}

Car(String model){
    this(model, "은색", 250);
}

Car(String model, String color){
    this(model, color, 250;)
}

Car(String model, String color, int maxSpeed){
    this.model = model;
    this.color = color;
    this.maxSpeed = maxSpeed;
}